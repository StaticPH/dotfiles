#! /bin/bash

__PROGNAME__="$(basename $0)"

# Honor the NO_COLOR environment variable
if [ ! -v NO_COLOR ]; then
	_RED_="\033[31m"
	# _YELLOW_="\033[33m"
	_OFF_="\033[0m"
else
	_RED_=
	# _YELLOW_=
	_OFF_=
fi

if ! command -v pacman &> /dev/null; then
	printf "${_RED_}ERROR: %s could not locate the \"pacman\" package manager. Exiting...${_OFF_}\n" "$__PROGNAME__" && exit 1
fi

usage(){
cat <<EOF
FLAGS:
   --completions  : output bash completion for $__PROGNAME__ to stdout.
   -h|--help      : Display this help text.
   -p             : (SYNC AND REMOVAL ONLY; Not Yet Implemented) Only simulate the command, do not execute it.

SUBCOMMANDS (Valid package operations):
   help    : Display this help text.
   removal : remove|autoremove
   sync    : install|update|download|upgrade|downgrade|
             info|show|cleanup|list|search|refresh
   query   : check|package-changelog|search-installed|
             owner-of|who-owns|list-package-owned|
             list-orphans|list-outdated|list-installed|
             list-explicitly-installed|list-dependencies|
             show-local
   file    : provides-what|find-providers
EOF
}

# Output usage and exit with return code 1 if the user provides no arguments
[ "$#" -eq 0 ] && usage && exit 1

pacman(){
	if [ ! -v NO_COLOR ]; then
		command pacman --color=auto $@
	else
		command pacman --color=never $@
	fi
}

# TODO: More intelligent completion that suggests arguments available to this subcommand
# TODO: For commands using the -U and -S flags, add support for --ignore and --needed
# TODO: For commands using the -R, -U and -S flags, add support for --nodeps, --assume-installed, and --print
# TODO: For commands using the -F flag, add support for --regex
completion(){
cat <<EOF
complete -W "remove autoremove install update download upgrade downgrade info show cleanup list \
search refresh check package-changelog search-installed owner-of who-owns list-package-owned list-orphans \
list-outdated list-installed list-explicitly-installed list-dependencies show-local provides-what \
find-providers help --completion" $__PROGNAME__
EOF
}


_helpTextOptions_F(){
	printf "%s\n" "Options:" \
		"   -x, --regex     Interpret each query as a regular expression."
}

_helpTextOptions_Q(){
	:
}

_helpTextOptions_R(){
	printf "%s\n" "Options:" \
		"   -h, --help      Display this help text." \
		"   -d, --nodeps    Skips pacman's normal dependency version checks. Package names are still checked. Specify this option twice to skip all dependency checks." \
		"   -p, --print     Only print the targets instead of performing the actual operation." \
		"" \
		"Options with arguments:" \
		"   --assume-installed <package=version>" \
		"      Add a virtual package \"package\" with version \"version\" to the transaction to satisfy dependencies. This allows disabling dependency checks for specific packages. To disable all dependency checking, see the --nodeps option." \
		"      This option can be specified multiple times."
}

_helpTextOptions_S(){
	printf "%s\n" "Options:" \
		"   -h, --help      Display this help text." \
		"   -d, --nodeps    Skips pacman's normal dependency version checks. Package names are still checked. Specify this option twice to skip all dependency checks." \
		"   -p, --print     Only print the targets instead of performing the actual operation." \
		"   --needed        Do not reinstall packages that are already up-to-date." \
		"" \
		"Options with arguments:" \
		"   --assume-installed <package=version>" \
		"      Add a virtual package \"package\" with version \"version\" to the transaction to satisfy dependencies. This allows disabling dependency checks for specific packages. To disable all dependency checking, see the --nodeps option." \
		"      This option can be specified multiple times." \
		"   --ignore <PKG_NAME,...>" \
		"      Ignore upgrades of package even if there is one available. Multiple packages can be specified by separating them with a comma." \
		"      This option can be specified multiple times."
}

getHelp(){
	# Call Reason: $__PROGNAME__ $1 [-h|--help]   OR $__PROGNAME__ help $1
	# example: pac install
	## Usage: $__PROGNAME__ $1 [options...] PKG_NAME...
	## Installs or updates packages available via the pacman package manager.
	## Analagous to `pacman -S`
	##
	## Options:
	##    -h, --help      Display this help text.
	##    -d, --nodeps    Skips pacman's normal dependency version checks. Package names are still checked. Specify this option twice to skip all dependency checks.
	##    -p, --print     Only print the targets instead of performing the actual operation.
	##    --needed        Do not reinstall packages that are already up-to-date.
	##
	## Options with arguments:
	##    --assume-installed <package=version>
	##       Add a virtual package "package" with version "version" to the transaction to satisfy dependencies. This allows disabling dependency checks for specific packages. To disable all dependency checking, see the --nodeps option.
	##       This option can be specified multiple times.
	##    --ignore <PKG_NAME,...>
	##       Ignore upgrades of package even if there is one available. Multiple packages can be specified by separating them with a comma.
	##       This option can be specified multiple times.
	##
	#
	#  CONSIDER: group commands that are equivalent, for example
	#    Usage:
	#       pac install [options...] PKG_NAME...
	#       pac update  [options...] PKG_NAME...
	case "$1" in
		# remove) &;
		# uninstall)
			# printf "%s\n" "Usage: $__PROGNAME__ $1 [options...] PKG_NAME..." \
			# "Uninstalls packages previously installed via the pacman package manager." \
			# "Analagous to `pacman -R`"
			# _helpTextOptions_R
		remove | uninstall)
			printf "%s\n" \
			"Usage: $__PROGNAME__ remove [options...] PKG_NAME..." \
			"       $__PROGNAME__ uninstall [options...] PKG_NAME..." \
			"Uninstalls packages previously installed via the pacman package manager." \
			"Analagous to `pacman -R`"
			_helpTextOptions_R
			;;
		autoremove)
			
			;;
		info | show)
			
			;;
		download)
			
			;;
		install | update)
			
			;;
		upgrade)
			
			;;
		downgrade)
			
			;;
		cleanup)
			
			;;
		list)
			
			;;
		search)
			
			;;
		refresh)
			# refresh the local sync database
			;;
		check)
			
			;;
		package-changelog)
			
			;;
		search-installed)
			
			;;
		owner-of | who-owns)
			
			;;
		list-package-owned)
			
			;;
		list-explicitly-installed)
			
			;;
		list-dependencies)
			
			;;
		list-orphans)
			
			;;
		list-outdated)
			# refresh the local sync database
			# check for out-of-date packages installed on the local system
			;;
		list-installed)
			
			;;
		show-local)
			
			;;
		provides-what)
			
			;;
		find-providers)
			# Find all packages IN THE SYNC DATABASE that provide the file(s) passed as arguments.
			# Each file argument will yield its own set of results, so the user can search for multiple files not provided by any single package.
			# Each package in the results will also list all files it provides that match the search term
			;;
		help)
			
			;;
		*)
			printf "${_RED_}%s%s${_OFF_}\n" \
				   "$__PROGNAME__: Unrecognized subcommand: \"$1\"" \
				   "For a list of available subcommands, try \"$__PROGNAME__ --help\""
			exit 1
			;;
	esac
	exit
}

case "$1" in
	-h | --help)
		usage && exit
		;;
	--completions)
		completion && exit
		;;
	-*)
		# No other options are allowed prior to a subcommand
		usage && exit 1
		;;
esac

# CONSIDER: separate subcommand option parsing functions according to the options applicable
# May want to examine /usr/share/doc/util-linux/getopt/getopt-parse.bash
		operation="$1" # facillitate TODO second-level help function that accepts the operation as a paremeter. i.e. `remove --help` calls `operationHelp "remove"`
		shift
		case "$operation" in
			remove | uninstall)
				pacman -R $*
				;;
			autoremove)
				pacman -R --recursive $@
				;;
			info | show)
				pacman -S --info --info $*
				;;
			download)
				pacman -S --downloadonly $*
				;;
			install | update) # treat both install and update as the same; although perhaps at least 'update' should specifically use '--needed'
				pacman -S $*
				;;
			upgrade)
				pacman -Sy --sysupgrade $@
				;;
			downgrade)
				pacman -S --sysupgrade --sysupgrade $@
				;;
			cleanup)
				pacman -S --clean $@
				;;
			list)
				pacman -S --list #$@
				;;
			search)
				pacman -S --search $*
				# TODO: change this to search separately for each distinct parameter group, collate the results, and remove duplicates
				# multiple parameters can be grouped into a single parameter by enclosing them in quotes,
				# and pacman will exhibit its default search behavior of searching for packages containing ALL of the strings within the quotes.
				# strings not within quotes are treated as separate search queries.
				;;
			refresh)
				pacman -Sy # refresh the local sync database
				;;
			check)
				if [ "$#" != 0 ];then
					pacman -Qkq "$@" | sed -Ee 's#(.*)( .*)#\1 is missing \2#'
				else
					# pacman -Qk |
					echo "TODO: support checking multiple specific packages at once"
					for pkg in $(pacman -Qqs); do
						# FIXME: I truly dont understand why this doesn't seem to work ( T.T)
						# TODO: REPLACE $(tput setaf 3) with __YELLOW__
						pacman -Qk "$pkg" | sed -E \
						-e 's#(warning: )(.+?)(:)(.+?)( \(No such file or directory\))# printf "%s%s%s%s" "$(tput setaf 3)\1$(tput sgr0)" "\2" " is missing" "\4"#e' \
						-e '/.*0 missing files$/!s/(.*total files, )(.*)/printf "%s%s" "\1" "$(tput setaf 3)\2$(tput sgr0)"/e'
					done
				fi
				;;
			package-changelog)
				pacman -Q --changelog $@
				;;
			search-installed)
				pacman -Q --search $*
				# TODO: See TODO on "search"
				;;
			owner-of | who-owns)
				# This functionality is also available through pkgfile.
				pacman -Q --owns $*
				# TODO: for windows users, consider OR-ing || pacman -Q --owns (...something that tries again with ".exe" appended to every argument)
				;;
			list-package-owned) 	#TODO: May deprecate completely, since -Fl seems to give the same results for installed packages
				pacman -Q --list $*
				# I don't fully understand the difference between -Ql and -Fl, because it _sounds_ like -Q --list only works when you have the package installed,
				# while -F --list works for all known packages (installed or not).
				;;
			list-explicitly-installed)
				pacman -Q --explicit $@
				;;
			list-dependencies)
				printf "%s\n" "Currently doesn't quite do what might be expected from the name."
				pacman -Q --deps $@
				;;
			list-orphans)
				pacman -Q --deps -t $@
				;;
			list-outdated) #list-out-of-date |
				pacman -Sy # refresh the local sync database
				pacman -Q --upgrades $@ #  check for out-of-date packages on the local system
				;;
			list-installed)
				pacman -Q --search
				;;
			show-local)
				pacman -Q --info --info $@
				;;
			provides-what)
				pacman -F --list $@ # Does not appear to be capable of finding SOME packages that don't show up with 'pacman -Q --search PKG_NAME', like pkgconf, but will for others, like dosfstools (at least from msys2)
				;;
			find-providers)
				# Find all packages IN THE SYNC DATABASE that provide the file(s) passed as arguments.
				# Each file argument will yield its own set of results, so the user can search for multiple files not provided by any single package.
				# Each package in the results will also list all files it provides that match the search term
				pacman -F $@
				;;
			help)
				[ "$#" -eq 0 ] && usage && exit
				[ "$#" -eq 1 ] && getHelp "$1"
				printf "${_RED_}$__PROGNAME__: Help: expected 0 or 1 arguments. Found %s arguments (%s)${_OFF_}\n" "$#" "$*"
				exit 1
				;;
			*)
				printf "${_RED_}%s${_OFF_}\n" "Invalid operation specified: \"$operation\" (use -h for help)"
				usage
				exit 1
				;;
		esac
